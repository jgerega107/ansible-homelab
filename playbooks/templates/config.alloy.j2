// Docker
discovery.docker "linux" {
	host = "unix:///var/run/docker.sock"
}
discovery.relabel "docker_log_relabel" {
	targets = discovery.docker.linux.targets
	rule {
		source_labels = ["__meta_docker_container_name"]
		regex         = "/(.*)"
		target_label  = "container_name"
	}
	rule {
		source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
		target_label  = "project_name"
	}
}

discovery.relabel "docker_metric_relabel_bridge" {
	targets = discovery.docker.linux.targets

	rule {
		source_labels = ["__meta_docker_container_name"]
		regex         = "/(.*)"
		target_label  = "container_name"
	}
	rule {
		source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
		target_label  = "project_name"
	}
	rule {
		source_labels = ["__meta_docker_container_label_metrics_port"]
		regex         = "(.+)"
		action        = "keep"
	}
	rule {
		source_labels = ["__meta_docker_container_label_metrics_port"]
		target_label = "__meta_docker_port_private"
		action        = "keepequal"
	}
	rule {
		source_labels = ["__meta_docker_port_public"]
		target_label  = "__address__"
		replacement   = "localhost:$1"
	}
	rule {
		source_labels = ["__meta_docker_port_public"]
		target_label  = "instance"
		replacement   = string.format("%s:%s", constants.hostname, "$1")
	}
}

discovery.relabel "docker_metric_relabel_host" {
	targets = discovery.docker.linux.targets

	rule {
		source_labels = ["__meta_docker_container_name"]
		regex         = "/(.*)"
		target_label  = "container_name"
	}
	rule {
		source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
		target_label  = "project_name"
	}
	rule {
		source_labels = ["__meta_docker_container_label_metrics_port"]
		regex         = "(.+)"
		action        = "keep"
	}
	rule {
		source_labels = ["__meta_docker_container_network_mode"]
		regex 		  = "host"
		action        = "keep"
	}
	rule {
		source_labels = ["__meta_docker_container_label_metrics_port"]
		target_label  = "__address__"
		replacement   = "localhost:$1"
	}
	rule {
		source_labels = ["__meta_docker_container_label_metrics_port"]
		target_label  = "instance"
		replacement   = string.format("%s:%s", constants.hostname, "$1")
	}
}
// Prometheus Exporters
prometheus.exporter.self "alloy_exporter" { }
prometheus.scrape "alloy_exporter_job" {
	targets    = prometheus.exporter.self.alloy_exporter.targets
	forward_to = [prometheus.remote_write.prom_remote.receiver]
}
prometheus.scrape "docker_container_metrics_bridge" {
	targets    = discovery.relabel.docker_metric_relabel_bridge.output
	forward_to = [prometheus.remote_write.prom_remote.receiver]
}
prometheus.scrape "docker_container_metrics_host" {
	targets    = discovery.relabel.docker_metric_relabel_host.output
	forward_to = [prometheus.remote_write.prom_remote.receiver]
}
prometheus.exporter.blackbox "alive_probes" {
	config = "{ modules: { icmp: { prober: icmp }, http_2xx: { prober: http, http: { follow_redirects: true, preferred_ip_protocol: ip4 } } } }"
	target {
		name = "gateway_icmp"
		address = "{{ ansible_default_ipv4.gateway }}"
		module = "icmp"
	}
	target {
		name = "google_http"
		address = "https://google.com"
		module = "http_2xx"
	}
}
prometheus.scrape "alive_probe_scrapes" {
	targets    = prometheus.exporter.blackbox.alive_probes.targets
	forward_to = [prometheus.remote_write.prom_remote.receiver]
	scrape_interval = "30s"
	scrape_timeout = "5s"
}
prometheus.exporter.cadvisor "docker" {
	docker_host = "unix:///var/run/docker.sock"
	docker_only = true
}
prometheus.scrape "base_exporters" {
	targets = array.concat([
		{"__address__" = string.format("%s:%s", constants.hostname, "9100"), "job" = "node_exporter"},
	], prometheus.exporter.cadvisor.docker.targets)
	forward_to = [prometheus.remote_write.prom_remote.receiver]
}
{% if ansible_virtualization_role != "guest" and smartctl_output.stdout_lines | length != 0 %}
prometheus.scrape "smartctl_exporter" {
	targets = [
		{"__address__" = string.format("%s:%s", constants.hostname, "9633"), "job" = "smartctl_exporter"},
	]
	forward_to = [prometheus.remote_write.prom_remote.receiver]
}
{% endif %}
{% if groups.nvidia is defined and inventory_hostname in groups.nvidia %}
prometheus.scrape "gpu_exporter" {
	targets = [
		{"__address__" = string.format("%s:%s", constants.hostname, "9835"), "job" = "gpu_exporter"},
	]
	forward_to = [prometheus.remote_write.prom_remote.receiver]
}
{% endif %}

// Loki
loki.source.docker "docker_log_scrape" {
	host          = "unix:///var/run/docker.sock"
	targets       = discovery.relabel.docker_log_relabel.output
	forward_to    = [loki.write.loki_remote.receiver]
}
loki.source.journal "journal_log_scrape"  {
	forward_to    = [loki.write.loki_remote.receiver]
	labels        = {"job" = "systemd-journal"}
	relabel_rules = loki.relabel.log_relabel.rules
}
loki.relabel "log_relabel" {
	forward_to = []

	rule {
		source_labels = ["__journal__systemd_unit"]
		target_label  = "service_name"
	}
}

// Receivers
prometheus.remote_write "prom_remote" {
	endpoint {
		url = "{{ alloy_remote_write_endpoint }}"
		send_native_histograms = true
{% if groups.remote is defined and inventory_hostname in groups.remote %}
		basic_auth {
			username = "{{ alloy_basic_auth_username }}"
			password = "{{ alloy_basic_auth_password }}"
		}
{% endif %}
	}

	external_labels = {"hostname" = constants.hostname}
}
loki.write "loki_remote" {
	endpoint {
		url = "{{ alloy_remote_log_endpoint }}"
{% if groups.remote is defined and inventory_hostname in groups.remote %}
		basic_auth {
			username = "{{ alloy_basic_auth_username }}"
			password = "{{ alloy_basic_auth_password }}"
		}
{% endif %}
	}
	external_labels = {"hostname" = constants.hostname}
}
